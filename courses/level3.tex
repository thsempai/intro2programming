% Level 3:
% Matière:
% ● Boucle logique (while)
% ● Comprendre l’utilité des fonction (et des méthodes)
% ● import de module Python
% ● utilisation de nombres aléatoires
% Exercices:
% 1. Remplacer la boucle for du bonus stage du level 2 par une boucle while
% conditioner sur la victoire (arrivée à la fin du labyrinthe) du héro.
% 2. Coder le mouvement des ennemis pour qu’il bouge de manière aléatoire, tout en
% évitant les obstacles.
% Bonus Stage:
% Faire sortir le héro du du donjon en évitant les obstacles et en attendant que les
% ennemis

% horaire du cours:

% 8h45
% 10h30
% 12h15
% 13h15
% 15h00
% 16h45


% présence: 10 min.
% -- 8h55
% Révision:
% 	Exercice: 30 min.
%	Correction: 20 min.  
% -- 9h45
% Boucle while 5 min.
% Exercice 10 min.
% -- 10h00


\chapter{Level 3}

\section{Les boucles logiques}

% checker dans la partie de Bastien comment il parle de la boucle et si il utilise le terme controler.
On a vu dans le chapitre précédent, la boucle dîtes arithmétique. Avec cette boucle, partie de code \emph{contrôlée} par celle-ci, s'exécute un nombre de fois précis.

Parfois, on sera intéressé que le programme s'arrête, non pas après un certain nombre de fois, mais plutôt lorsque qu'une certaine condition est remplie. Pour se faire on fait appelle au \emph{boucle logique}.

En python, c'est l'instruction \codeintext{while}\footnote{"Tant que" en anglais} qui est utilisée.

Cette instruction doit être suivit d'une \emph{condition}, celle-ci va déterminé à chaque \emph{itération}, si le programme doit continuer ou non d'exécuter la boucle.

Dans le script suivant, la boucle sera exécuter tant qu'il reste des monstres.

\begin{lstlisting}
while monsters_nbr >= 0:
	hero_kills = hero.attacks()
	monster_nbr = monster_nbr - hero_kills
	game.run()
\end{lstlisting}

La méthode \codeintext{attacks} de la variable \codeintext{hero} renvoie 1 ou 0, donc il est impossible de savoir combien d'itération seront nécessaire pour réduire la variable \codeintext{monsters\_nbr} à 0.
C'est donc un \emph{boucle logique} qui utilisée dans ce genre de cas.

%% voir dans le level 2 comment Bastien parle  des booleens.
La condition qui contrôle la boucle est similaire à la condition utilisée avec l'instruction \codeintext{if}.
La boucle s'arrête lorsque la condition est \emph{faux}.

Dans le cas de notre script, c'est lorsque le nombre de monstre passe en-dessus de 0 que la condition devient \emph{fausse}.

\subsection{Stage 3-1}

Reprenez le \textit{bonus stage} du \textit{level 2}\footnote{au besoin le code corrigé de cette exercices ce trouve dans le script \path{bonus\_stage\_2.py}}. Arrangez ce code avec une \emph{boucle logique} à la place de la \emph{boucle arithmétique} pour le héros arrête de bouger dès qu'il est arrivé à destination et non après un nombre d'itération arbitraire.
Lorsque le héros a atteint sa cible, la variable \codeintext{hero.on\_goal} vaut \codeintext{True}, dans les autres cas elle est égale à \codeintext{False}.

\section{les imports}

En Python, il est courant de devoir \emph{importer} le contenu de fichier dans d'autre fichier.
\`A plusieurs reprise, on déjà vu cette instruction dans les scripts que l'on a utilisé:

\begin{lstlisting}
import world
\end{lstlisting}

Cette commande, demande à python d'\emph{importer} le contenu du fichier \path{world.py} en vue de l'utiliser plus tard.
Dans la suite, si l'on veut faire appel au contenu de \codeintext{world}, on doit utilisé son nom suivit d'un "\codeintext{.}"

Par exemple si je veux utiliser la variable \codeintext{SCREEN\_SIZE} dans mon script je vais procéder comme suit:

\begin{lstlisting}
import world

scree_size = world.SCREEN_SIZE
\end{lstlisting}

On peut aussi n'\emph{importer} qu'une partie d'un module\footnote{C'est le nom que l'on donne au fichier que l'on importe}.

\begin{lstlisting}
from world import SCREEN_SIZE
\end{lstlisting}

En procédant de cette manière, on n'\emph{importe} que la variable \codeintext{SCREEN\_SIZE}.
Cela présente l'avantage de ne devoir précédé la variable \codeintext{SCREEN\_SIZE} de \codeintext{world.}, on peut se contenter du nom de la variable seul.

\begin{lstlisting}
from world import SCREEN_SIZE

screen_size = SCREEN_SIZE
\end{lstlisting}

Et enfin, on peut \emph{importer} plusieurs composant d'un module sur la même ligne.
Si je voulais importer \codeintext{SCREEN\_SIZE} et la variable \codeintext{TILE\_SIZE}, je procéderais ainsi:

\begin{lstlisting}
from world import SCREEN_SIZE, TILE_SIZE
\end{lstlisting}
